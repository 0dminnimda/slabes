# PEG grammar for Slabes

@class SlabesParser

@header'''
#!/usr/bin/env python
# @generated by pegen from {filename}

import sys
import tokenize
import itertools
import typing

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger
from . import ast_nodes as ast
from .parser_base import ParserBase as Parser, parser_main
'''


@trailer'''
if __name__ == '__main__':
    parser_main(SlabesParser)
'''


start[ast.Module]: a=statements ENDMARKER { ast.Module(a, LOCATIONS) }

statements[list[ast.Statement]]:
    | a=statement_group+ { list(itertools.chain.from_iterable(a)) }


statement_group[list[ast.Statement]]:
    | stmts=(','+).statement+ ','* '.' { stmts }

statement[ast.Statement]:
    | &UNTIL ~ until_stmt { until_stmt }
    | &CHECK ~ check_stmt { check_stmt }
    | function_definition { function_definition }
    | declaration { declaration }
    | expr=expr { ast.SingleExpression(expr, LOCATIONS) }


function_definition[ast.Function]:
    | ret=number_type name=identifier args=(','.argument+)? ','? BEGIN b=statement_group END {
        ast.Function(ret, name.value, [] if args is None else args, b, LOCATIONS)
    }
    | recover_function_definition

recover_function_definition:
    | ret=word name=word args=(','.argument+)? ','? BEGIN b=statement_group END {
        ast.Function(
            self.make_number_type(ret, **self.locs(ret)),
            self.make_name(name, **self.locs(name)).value,
            [] if args is None else args,
            b,
            LOCATIONS
        )
    }


argument[ast.Argument]:
    | tp=number_type id=identifier {
        ast.Argument(tp, id, LOCATIONS)
    }
    | recover_argument

recover_argument:
    | tp=word id=word {
        ast.Argument(
            self.make_number_type(tp, **self.locs(tp)),
            self.make_name(id, **self.locs(id)),
            LOCATIONS
        )
    }


until_stmt[ast.Until]:
    | UNTIL expr DO statement_group { 
        ast.Until(expr, statement_group, LOCATIONS)
    }


check_stmt[ast.Check]:
    | CHECK expr DO statement_group { 
        ast.Check(expr, statement_group, LOCATIONS)
    }


declaration[ast.NumberDeclaration]:
    | &FIELD ~ array_declaration
    | number_declaration


array_declaration[ast.ArrayDeclaration]:
    | FIELD elem_t=number_type size_t=number_type names=identifier+ '<<' val=expr {
        self.make_array_declaration(elem_t, size_t, names, val, LOCATIONS)
    }
    | recover_array_declaration

recover_array_declaration[ast.ArrayDeclaration]:
    | FIELD elem_t=word size_t=word names=word+ '<<' val=expr {
        self.make_array_declaration(
            self.make_number_type(elem_t, **self.locs(elem_t)),
            self.make_number_type(size_t, **self.locs(size_t)),
            [self.make_name(name, **self.locs(name)) for name in names],
            val,
            LOCATIONS
        )
    }


number_declaration[ast.NumberDeclaration]:
    | type=number_type names=identifier+ '<<' val=expr {
        self.make_number_declaration(type, names, val, LOCATIONS)
    }
    | recover_number_declaration

recover_number_declaration[ast.NumberDeclaration]:
    | type=word names=word+ '<<' val=expr {
        self.make_number_declaration(
            self.make_number_type(type, **self.locs(type)),
            [self.make_name(name, **self.locs(name)) for name in names],
            val,
            LOCATIONS
        )
    }


expr[ast.Expression]:
    | assignment
    | invalid_expr

invalid_expr:
    | a=declaration {
        self.report_syntax_error_at(
            "expected expression, got declaration."
            " Did you mean to use '.' before/after this declaration?",
            a,
            fatal=True,
        )
    }


assignment:
    | start=comparison rest=(('<<' | '>>') comparison)+ { self.make_assignment(start, rest, LOCATIONS) }
    | comparison

comparison:
    # | a=comparison '<>' b=sum { ast.CompareOperation(a, ast.Add(), b, LOCATIONS) }
    # | a=comparison '<=' b=sum { ast.CompareOperation(a, ast.Add(), b, LOCATIONS) }
    # | a=comparison '=>' b=sum { ast.CompareOperation(a, ast.Add(), b, LOCATIONS) }
    | sum

sum:
    | a=sum '+' b=term { ast.BinaryOperation(a, ast.BinOp.ADD, b, LOCATIONS) }
    | a=sum '-' b=term { ast.BinaryOperation(a, ast.BinOp.SUB, b, LOCATIONS) }
    | term

term:
    | a=term '\\' b=factor { ast.BinaryOperation(a, ast.BinOp.MUL, b, LOCATIONS) }
    | a=term '/' b=factor { ast.BinaryOperation(a, ast.BinOp.DIV, b, LOCATIONS) }
    | factor

factor (memo):
    # | '+' a=factor { ast.UnaryOperation(ast.UAdd(), operand=a, LOCATIONS) }
    # | '-' a=factor { ast.UnaryOperation(ast.USub(), operand=a, LOCATIONS) }
    | primary


primary:
    | subscript
    | atom


subscript[ast.Subscript]:
    | a=primary '[' exprs=expr* ']' { self.make_subscript(a, exprs, LOCATIONS) }
    | recover_subscript

recover_subscript[ast.Subscript]:
    | a=word '[' exprs=expr* ']' {
        self.make_subscript(self.make_name(a, **self.locs(a)), exprs, LOCATIONS)
    }


atom:
    | identifier
    | signed_number
    | robot_operation
    | &'(' group
    | recover_atom

recover_atom: a=word { self.make_name(a, LOCATIONS) }


group:
    | '(' a=comparison ')' { a }


robot_operation[ast.RobotOperation]: op=robot_keyword { self.make_robot_op(op, LOCATIONS) }
robot_keyword: GO | RL | RR | SONAR | COMPASS


signed_number[ast.NumericLiteral]: sign=sign? num=NUMBER { self.make_number(num, sign, LOCATIONS) }

sign: '+' | '-'


# ugh bug in pegen
number_type[ast.NumbeTypeRef]: a=number_type_raw { self.make_number_type(a, LOCATIONS) }
number_type_raw: TINY | SMALL | NORMAL | BIG


identifier[ast.Name]: a=NAME { self.make_name(a, LOCATIONS) }


word: NAME | keyword

keyword: number_type_raw | FIELD | BEGIN | END | UNTIL | DO | CHECK | robot_keyword
