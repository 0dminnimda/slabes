# PEG grammar for Slabes

@class SlabesParser

@header'''
#!/usr/bin/env python
# @generated by pegen from {filename}

import sys
import tokenize
import itertools
import typing

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger
from . import ast_nodes as ast
from .parser_base import ParserBase as Parser, parser_main
'''


@trailer'''
if __name__ == '__main__':
    parser_main(SlabesParser)
'''


start[ast.Module]: a=statements ENDMARKER { ast.Module(a[0], LOCATIONS) }

# need to return a tuple, because bool([]) == False, wihch pegen trets a rule failure
statements[tuple[list[ast.Statement]]]:
    | a=statement_group+ { (list(itertools.chain.from_iterable(i[0] for i in a)),) }


# need to return a tuple, because bool([]) == False, wihch pegen trets a rule failure
statement_group[tuple[list[ast.Statement]]]:
    | stmts=((','+).statement+)? ','* '.' { ([] if stmts is None else stmts,) }

statement[ast.Statement]:
    | &UNTIL ~ until_stmt { until_stmt }
    | &CHECK ~ check_stmt { check_stmt }
    | &RETURN ~ return_stmt { return_stmt }
    | function_definition { function_definition }
    | declaration { declaration }
    | expr=expr { ast.SingleExpression(expr, LOCATIONS) }


function_definition[ast.Function]:
    | ret=number_type name=identifier args=(','.argument+)? ','? BEGIN b=statement_group END {
        ast.Function(ret, name.value, [] if args is None else args, b[0], LOCATIONS)
    }
    | recover_function_definition
    | invalid_function_definition

recover_function_definition:
    | ret=word name=word args=(','.argument+)? ','? BEGIN b=statement_group END {
        ast.Function(
            self.make_number_type(ret, **self.locs(ret)),
            self.make_name(name, **self.locs(name)).value,
            [] if args is None else args,
            b[0],
            LOCATIONS
        )
    }

invalid_function_definition:
    | word word (','.argument+)? ','? b=BEGIN statement_group? {
        self.report_syntax_error_at(
            "'BEGIN' was never matched with 'END'",
            b,
            fatal=True,
        )
    }


argument[ast.Argument]:
    | tp=number_type id=identifier { ast.Argument(tp, id, LOCATIONS) }
    | recover_argument

recover_argument:
    | tp=word id=word {
        ast.Argument(
            self.make_number_type(tp, **self.locs(tp)),
            self.make_name(id, **self.locs(id)),
            LOCATIONS
        )
    }


return_stmt[ast.Return]:
    | RETURN expr { ast.Return(expr, LOCATIONS) }
    | invalid_return_stmt

invalid_return_stmt:
    | b=RETURN {
        self.report_syntax_error_at(
            "cannot return nothing",
            b,
            fatal=True,
        )
    }


until_stmt[ast.Until]:
    | UNTIL expr DO statement_group { ast.Until(expr, statement_group[0], LOCATIONS) }
    | invalid_until_stmt

invalid_until_stmt:
    | b=UNTIL expr? {
        self.report_syntax_error_at(
            "'UNTIL' was never matched with 'DO'",
            b,
            fatal=True,
        )
    }


check_stmt[ast.Check]:
    | CHECK expr DO statement_group {  ast.Check(expr, statement_group[0], LOCATIONS) }
    | invalid_check_stmt

invalid_check_stmt:
    | b=CHECK expr? {
        self.report_syntax_error_at(
            "'CHECK' was never matched with 'DO'",
            b,
            fatal=True,
        )
    }


declaration[ast.NumberDeclaration]:
    | &FIELD ~ array_declaration
    | number_declaration


array_declaration[ast.ArrayDeclaration]:
    | FIELD elem_t=number_type size_t=number_type names=identifier+ '<<' val=expr {
        self.make_array_declaration(elem_t, size_t, names, val, LOCATIONS)
    }
    | recover_array_declaration

recover_array_declaration[ast.ArrayDeclaration]:
    | FIELD elem_t=word size_t=word names=word+ '<<' val=expr {
        self.make_array_declaration(
            self.make_number_type(elem_t, **self.locs(elem_t)),
            self.make_number_type(size_t, **self.locs(size_t)),
            [self.make_name(name, **self.locs(name)) for name in names],
            val,
            LOCATIONS
        )
    }


number_declaration[ast.NumberDeclaration]:
    | type=number_type names=identifier+ '<<' val=expr {
        self.make_number_declaration(type, names, val, LOCATIONS)
    }
    | recover_number_declaration

recover_number_declaration[ast.NumberDeclaration]:
    | type=word names=word+ '<<' val=expr {
        self.make_number_declaration(
            self.make_number_type(type, **self.locs(type)),
            [self.make_name(name, **self.locs(name)) for name in names],
            val,
            LOCATIONS
        )
    }


expr[ast.Expression]:
    | assignment

assignment:
    | start=comparison rest=(('<<' | '>>') comparison)+ { self.make_assignment(start, rest, LOCATIONS) }
    | comparison

comparison:
    # | a=comparison '<>' b=sum { ast.CompareOperation(a, ast.Add(), b, LOCATIONS) }
    # | a=comparison '<=' b=sum { ast.CompareOperation(a, ast.Add(), b, LOCATIONS) }
    # | a=comparison '=>' b=sum { ast.CompareOperation(a, ast.Add(), b, LOCATIONS) }
    | sum

sum:
    | a=sum '+' b=term { ast.BinaryOperation(a, ast.BinOp.ADD, b, LOCATIONS) }
    | a=sum '-' b=term { ast.BinaryOperation(a, ast.BinOp.SUB, b, LOCATIONS) }
    | term

term:
    | a=term '\\' b=factor { ast.BinaryOperation(a, ast.BinOp.MUL, b, LOCATIONS) }
    | a=term '/' b=factor { ast.BinaryOperation(a, ast.BinOp.DIV, b, LOCATIONS) }
    | factor

factor (memo):
    # | '+' a=factor { ast.UnaryOperation(ast.UAdd(), operand=a, LOCATIONS) }
    # | '-' a=factor { ast.UnaryOperation(ast.USub(), operand=a, LOCATIONS) }
    | primary


primary:
    | subscript
    | call
    | atom


subscript[ast.Subscript]:
    | a=primary '[' exprs=expr* ']' { self.make_subscript(a, exprs, LOCATIONS) }
    | recover_subscript
    | invalid_subscript

recover_subscript[ast.Subscript]:
    | a=word '[' exprs=expr* ']' {
        self.make_subscript(self.make_name(a, **self.locs(a)), exprs, LOCATIONS)
    }

invalid_subscript:
    | word b='[' expr* {
        self.report_syntax_error_at(
            "'[' was never closed",
            b,
            fatal=True,
        )
    }


call[ast.Call]:
    | a=primary '(' exprs=expr* ')' { self.make_call(a, exprs, LOCATIONS) }
    | recover_call
    | invalid_call

recover_call[ast.Call]:
    | a=word '(' exprs=expr* ')' {
        self.make_call(self.make_name(a, **self.locs(a)), exprs, LOCATIONS)
    }

invalid_call:
    | word b='(' expr* {
        self.report_syntax_error_at(
            "'(' was never closed",
            b,
            fatal=True,
        )
    }


atom:
    | identifier
    | signed_number
    | robot_operation
    | &'(' group
    | recover_atom

recover_atom: a=word { self.make_name(a, LOCATIONS) }


group:
    | '(' a=comparison ')' { a }
    | invalid_group

invalid_group:
    | b='(' comparison {
        self.report_syntax_error_at(
            "'(' was never closed",
            b,
            fatal=True,
        )
    }


robot_operation[ast.RobotOperation]: op=robot_keyword { self.make_robot_op(op, LOCATIONS) }
robot_keyword: GO | RL | RR | SONAR | COMPASS


signed_number[ast.NumericLiteral]: sign=sign? num=NUMBER { self.make_number(num, sign, LOCATIONS) }

sign: '+' | '-'


# ugh bug in pegen
number_type[ast.NumbeTypeRef]: a=number_type_raw { self.make_number_type(a, LOCATIONS) }
number_type_raw: TINY | SMALL | NORMAL | BIG


identifier[ast.Name]: a=NAME { self.make_name(a, LOCATIONS) }


word: NAME | keyword

keyword: number_type_raw | FIELD | BEGIN | END | UNTIL | DO | CHECK | robot_keyword
