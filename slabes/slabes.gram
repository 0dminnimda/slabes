# PEG grammar for Slabes

@class SlabesParser

@header'''
#!/usr/bin/env python
# @generated by pegen from {filename}

import sys
import tokenize
import typing

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger
from . import ast_nodes as ast
from .parser_base import ParserBase as Parser, parser_main
'''


@trailer'''
if __name__ == '__main__':
    parser_main(SlabesParser)
'''


start: a=statements ENDMARKER {
    ast.Module(a, LOCATIONS)
}

statements: a=statement* { a }

statement:
    | declaration '.' {
        declaration
    }
    | expr=expr exprs=compound_expr_not_first* '.' {
        ast.CompoundExpression([expr] + exprs, LOCATIONS)
    }

compound_expr_not_first: ',' a=expr { a }

expr:
    | atom
    | invalid_expr

invalid_expr:
    | a=declaration {
        self.raise_syntax_error_at(
            "expected expression, got declaration."
            " Did you mean to use '.' before/after this declaration?",
            a,
            fatal=True,
        )
    }

declaration: number_declaration

number_declaration:
    | type=number_type names=identifier+ '<<' signed_number {
        self.make_number_declaration(type, names, signed_number, LOCATIONS)
    }
    | bad_number_declaration

bad_number_declaration:
    | type=word names=word+ '<<' signed_number {
        self.make_number_declaration(
            self.make_number_type(type, **self.locs(type)),
            [self.make_name(name, **self.locs(name)) for name in names],
            signed_number,
            LOCATIONS
        )
    }


atom:
    | identifier
    | signed_number

signed_number: sign=sign? num=NUMBER {
    self.make_number(num, sign is not None and sign.string == "-", LOCATIONS)
}

sign: '+' | '-'

number_type: a=number_type_ {
    self.make_number_type(a, LOCATIONS)
}
number_type_: TINY | SMALL | NORMAL | BIG  # ugh bug in pegen

identifier: a=NAME {
    self.make_name(a, LOCATIONS)
}

word: NAME | keywords

keywords: TINY | SMALL | NORMAL | BIG
