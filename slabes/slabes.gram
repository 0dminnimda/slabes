# PEG grammar for Slabes

@class SlabesParser

@header'''
#!/usr/bin/env python
# @generated by pegen from {filename}

import sys
import tokenize
import typing

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger
from . import ast_nodes as ast
from .parser_base import ParserBase as Parser, parser_main
'''


@trailer'''
if __name__ == '__main__':
    parser_main(SlabesParser)
'''


start: a=statements ENDMARKER {
    ast.Module(a, LOCATIONS)
}

statements[list[ast.Statement]]: a=statement* { a }

statement[ast.Statement]:
    | declaration '.' {
        declaration
    }
    | exprs=','.expr+ '.' {
        ast.CompoundExpression(exprs, LOCATIONS)
    }

expr[ast.Expression]:
    | primary
    | invalid_expr

invalid_expr:
    | a=declaration {
        self.raise_syntax_error_at(
            "expected expression, got declaration."
            " Did you mean to use '.' before/after this declaration?",
            a,
            fatal=True,
        )
    }

declaration[ast.NumberDeclaration]:
    | array_declaration
    | number_declaration

array_declaration[ast.ArrayDeclaration]:
    | FIELD elem_t=number_type size_t=number_type names=identifier+ '<<' signed_number {
        self.make_array_declaration(elem_t, size_t, names, signed_number, LOCATIONS)
    }
    | recover_array_declaration

recover_array_declaration[ast.ArrayDeclaration]:
    | FIELD elem_t=word size_t=word names=word+ '<<' signed_number {
        self.make_array_declaration(
            self.make_number_type(elem_t, **self.locs(elem_t)),
            self.make_number_type(size_t, **self.locs(size_t)),
            [self.make_name(name, **self.locs(name)) for name in names],
            signed_number,
            LOCATIONS
        )
    }


number_declaration[ast.NumberDeclaration]:
    | type=number_type names=identifier+ '<<' signed_number {
        self.make_number_declaration(type, names, signed_number, LOCATIONS)
    }
    | recover_number_declaration

recover_number_declaration[ast.NumberDeclaration]:
    | type=word names=word+ '<<' signed_number {
        self.make_number_declaration(
            self.make_number_type(type, **self.locs(type)),
            [self.make_name(name, **self.locs(name)) for name in names],
            signed_number,
            LOCATIONS
        )
    }


primary:
    | subscript
    | atom

subscript[ast.Subscript]:
    | a=expr '[' exprs=expr* ']' {
        self.make_subscript(a, exprs, LOCATIONS)
    }
    | recover_subscript

recover_subscript:
    | a=word '[' exprs=expr* ']' {
        self.make_subscript(self.make_name(a, **self.locs(a)), exprs, LOCATIONS)
    }

atom:
    | identifier
    | signed_number

signed_number[ast.NumberLiteral]: sign=sign? num=NUMBER {
    self.make_number(num, sign, LOCATIONS)
}

sign: '+' | '-'

# ugh bug in pegen
number_type[ast.NumberType]: a=number_type_raw {
    self.make_number_type(a, LOCATIONS)
}
number_type_raw: TINY | SMALL | NORMAL | BIG

identifier[ast.Name]: a=NAME {
    self.make_name(a, LOCATIONS)
}

word: NAME | keyword

keyword: number_type_raw | FIELD
