
#!/usr/bin/env python
# @generated by pegen from slabes/slabes.gram

import sys
import tokenize
import typing

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger
from . import ast_nodes as ast
from .parser_base import ParserBase as Parser, parser_main
# Keywords and soft keywords are listed at the end of the parser definition.
class SlabesParser(Parser):

    @memoize
    def start(self) -> Optional[Any]:
        # start: expr* $
        mark = self._mark()
        if (
            (_loop0_1 := self._loop0_1(),)
            and
            (_endmarker := self.expect('ENDMARKER'))
        ):
            return [_loop0_1, _endmarker];
        self._reset(mark)
        return None;

    @memoize
    def expr(self) -> Optional[Any]:
        # expr: term '+' expr | ((sign sign))+ term '-' expr | term
        mark = self._mark()
        if (
            (term := self.term())
            and
            (literal := self.expect('+'))
            and
            (expr := self.expr())
        ):
            return [term, literal, expr];
        self._reset(mark)
        if (
            (_loop1_2 := self._loop1_2())
            and
            (term := self.term())
            and
            (literal := self.expect('-'))
            and
            (expr := self.expr())
        ):
            return [_loop1_2, term, literal, expr];
        self._reset(mark)
        if (
            (term := self.term())
        ):
            return term;
        self._reset(mark)
        return None;

    @memoize
    def sign(self) -> Optional[Any]:
        # sign: '+' | '-'
        mark = self._mark()
        if (
            (literal := self.expect('+'))
        ):
            return literal;
        self._reset(mark)
        if (
            (literal := self.expect('-'))
        ):
            return literal;
        self._reset(mark)
        return None;

    @memoize
    def term(self) -> Optional[Any]:
        # term: factor '*' term | factor '/' term | factor
        mark = self._mark()
        if (
            (factor := self.factor())
            and
            (literal := self.expect('*'))
            and
            (term := self.term())
        ):
            return [factor, literal, term];
        self._reset(mark)
        if (
            (factor := self.factor())
            and
            (literal := self.expect('/'))
            and
            (term := self.term())
        ):
            return [factor, literal, term];
        self._reset(mark)
        if (
            (factor := self.factor())
        ):
            return factor;
        self._reset(mark)
        return None;

    @memoize
    def factor(self) -> Optional[Any]:
        # factor: '(' expr ')' | atom
        mark = self._mark()
        if (
            (literal := self.expect('('))
            and
            (expr := self.expr())
            and
            (literal_1 := self.expect(')'))
        ):
            return [literal, expr, literal_1];
        self._reset(mark)
        if (
            (atom := self.atom())
        ):
            return atom;
        self._reset(mark)
        return None;

    @memoize
    def atom(self) -> Optional[Any]:
        # atom: NAME | NUMBER
        mark = self._mark()
        if (
            (name := self.name())
        ):
            return name;
        self._reset(mark)
        if (
            (number := self.number())
        ):
            return number;
        self._reset(mark)
        return None;

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: expr
        mark = self._mark()
        children = []
        while (
            (expr := self.expr())
        ):
            children.append(expr)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _loop1_2(self) -> Optional[Any]:
        # _loop1_2: (sign sign)
        mark = self._mark()
        children = []
        while (
            (_tmp_3 := self._tmp_3())
        ):
            children.append(_tmp_3)
            mark = self._mark()
        self._reset(mark)
        return children;

    @memoize
    def _tmp_3(self) -> Optional[Any]:
        # _tmp_3: sign sign
        mark = self._mark()
        if (
            (sign := self.sign())
            and
            (sign_1 := self.sign())
        ):
            return [sign, sign_1];
        self._reset(mark)
        return None;

    KEYWORDS = ()
    SOFT_KEYWORDS = ()

if __name__ == '__main__':
    parser_main(SlabesParser)
